/**
 * AI-generated code pattern analyzer.
 * Detects signatures from Cursor, Bolt, Lovable, Copilot, and other AI tools.
 * Focuses on quality anti-patterns common in AI-generated code.
 * Zero dependencies — pure Node.js.
 */

import { readLines } from '../utils/line-reader.mjs';
import { finding, SEVERITY } from '../utils/severity.mjs';

const ANALYZER = 'ai-patterns';

const CODE_EXTENSIONS = new Set([
  '.js', '.mjs', '.cjs', '.jsx', '.ts', '.tsx',
  '.py', '.rb', '.go', '.rs', '.java', '.kt',
  '.ex', '.exs', '.php', '.cs', '.swift',
  '.vue', '.svelte', '.astro',
]);

/**
 * AI tool fingerprints — comments, annotations, and patterns left by tools.
 */
const AI_FINGERPRINTS = [
  { pattern: /Generated by Cursor/i, tool: 'Cursor' },
  { pattern: /Created with Bolt/i, tool: 'Bolt' },
  { pattern: /Built with Lovable/i, tool: 'Lovable' },
  { pattern: /Generated by Copilot/i, tool: 'GitHub Copilot' },
  { pattern: /Co-authored-by:.*copilot/i, tool: 'GitHub Copilot' },
  { pattern: /Generated by ChatGPT/i, tool: 'ChatGPT' },
  { pattern: /Generated by Claude/i, tool: 'Claude' },
  { pattern: /AI-generated|auto-generated code/i, tool: 'Unknown AI' },
  { pattern: /v0\.dev/i, tool: 'v0' },
  { pattern: /Generated by Codeium/i, tool: 'Codeium' },
  { pattern: /Generated by Tabnine/i, tool: 'Tabnine' },
  { pattern: /windsurf/i, tool: 'Windsurf' },
];

/**
 * Quality anti-patterns common in AI-generated code.
 */
const AI_QUALITY_PATTERNS = [
  {
    name: 'Silent catch (empty error handler)',
    regex: /catch\s*\([^)]*\)\s*\{\s*\}/,
    severity: SEVERITY.MEDIUM,
    description: 'Empty catch block silently swallows errors. This hides bugs and makes debugging extremely difficult.',
    remediation: 'At minimum, log the error. Better: handle the error or let it propagate.',
  },
  {
    name: 'Console.log left in production code',
    regex: /console\.log\s*\(/,
    severity: SEVERITY.LOW,
    description: 'console.log statement found. AI tools often leave debug logging in generated code.',
    remediation: 'Remove debug logging or replace with a proper logging library.',
    testExclude: true,
  },
  {
    name: 'TODO/FIXME/HACK comment',
    regex: /\/\/\s*(?:TODO|FIXME|HACK|XXX|TEMP|TEMPORARY)\b/i,
    severity: SEVERITY.LOW,
    description: 'Unresolved TODO/FIXME comment. AI tools often leave placeholder comments for incomplete implementations.',
    remediation: 'Resolve the TODO or create a tracked issue for it.',
  },
  {
    name: 'any type usage (TypeScript)',
    regex: /:\s*any\b(?!\s*\/\/\s*eslint)/,
    severity: SEVERITY.LOW,
    description: 'TypeScript `any` type bypasses type checking. AI tools frequently use `any` to avoid complex type definitions.',
    remediation: 'Replace `any` with proper types. Use `unknown` if the type is truly unknown.',
    extensions: ['.ts', '.tsx'],
  },
  {
    name: 'Duplicated error message string',
    regex: /(?:throw new Error|console\.error|reject)\s*\(\s*['"](?:Something went wrong|An error occurred|Error|Unknown error|Failed)['"]/i,
    severity: SEVERITY.LOW,
    description: 'Generic error message. AI tools often use vague error messages that provide no diagnostic value.',
    remediation: 'Use specific, descriptive error messages that help identify the problem.',
  },
  {
    name: 'Commented-out code block',
    regex: /^\s*\/\/\s*(?:const|let|var|function|class|import|export|if|for|while|return|async)\b/,
    severity: SEVERITY.LOW,
    description: 'Commented-out code found. AI tools often leave previous iterations as comments instead of removing them.',
    remediation: 'Remove commented-out code. Use version control to track history.',
  },
  {
    name: 'Excessive try-catch wrapping',
    regex: /try\s*\{[\s\S]{0,50}try\s*\{/,
    severity: SEVERITY.LOW,
    description: 'Nested try-catch blocks. AI tools sometimes wrap every operation in try-catch, adding noise without value.',
    remediation: 'Consolidate error handling. Use a single try-catch at appropriate boundaries.',
    multiline: true,
  },
];

/**
 * Structural patterns that suggest AI generation.
 */
const STRUCTURAL_PATTERNS = {
  /** Files that are suspiciously similar (near-duplicate logic) */
  duplicateThreshold: 0.85,
  /** Inconsistent naming within a file */
  namingPatterns: {
    camelCase: /^[a-z][a-zA-Z0-9]*$/,
    snake_case: /^[a-z][a-z0-9_]*$/,
    PascalCase: /^[A-Z][a-zA-Z0-9]*$/,
  },
};

/**
 * Run the AI patterns analyzer.
 *
 * @param {string} rootDir
 * @param {object[]} files
 * @returns {Promise<{ findings: object[], stats: object }>}
 */
export async function analyzeAiPatterns(rootDir, files) {
  const findings = [];
  const codeFiles = files.filter(f => CODE_EXTENSIONS.has(f.ext));
  const stats = {
    filesAnalyzed: codeFiles.length,
    aiToolFingerprints: [],
    silentCatches: 0,
    genericErrors: 0,
    commentedOutCode: 0,
    todoComments: 0,
  };

  // Track file content hashes for duplicate detection
  const contentSignatures = new Map(); // signature -> [files]

  for (const file of codeFiles) {
    const result = await readLines(file.absolutePath);
    if (!result) continue;

    const isTestFile = /(?:\.test\.|\.spec\.|__tests__|test_|_test\.)/.test(file.relativePath);

    // Check for AI tool fingerprints
    for (const { pattern, tool } of AI_FINGERPRINTS) {
      for (let i = 0; i < Math.min(result.lines.length, 20); i++) {
        if (pattern.test(result.lines[i])) {
          if (!stats.aiToolFingerprints.find(f => f.tool === tool && f.file === file.relativePath)) {
            stats.aiToolFingerprints.push({ tool, file: file.relativePath, line: i + 1 });
          }
        }
      }
    }

    // Check quality anti-patterns
    let silentCatchesInFile = 0;
    for (let i = 0; i < result.lines.length; i++) {
      const line = result.lines[i];
      const trimmed = line.trim();

      for (const pattern of AI_QUALITY_PATTERNS) {
        if (pattern.extensions && !pattern.extensions.includes(file.ext)) continue;
        if (pattern.testExclude && isTestFile) continue;
        if (pattern.multiline) continue; // Handle separately

        if (pattern.regex.test(trimmed)) {
          // Track stats
          if (pattern.name.includes('Silent catch')) {
            silentCatchesInFile++;
            stats.silentCatches++;
          } else if (pattern.name.includes('TODO')) {
            stats.todoComments++;
          } else if (pattern.name.includes('Commented-out')) {
            stats.commentedOutCode++;
          } else if (pattern.name.includes('error message')) {
            stats.genericErrors++;
          }
        }
      }
    }

    // Report excessive silent catches per file
    if (silentCatchesInFile >= 3) {
      findings.push(finding({
        analyzer: ANALYZER,
        severity: SEVERITY.MEDIUM,
        title: `${silentCatchesInFile} silent catch blocks in ${file.relativePath}`,
        description: `This file has ${silentCatchesInFile} empty catch blocks that silently swallow errors. This is a common AI-generated code pattern that makes debugging very difficult.`,
        file: file.relativePath,
        remediation: 'Add error logging or proper error handling to each catch block.',
      }));
    }

    // Check for inconsistent naming within a single file
    const namingIssue = detectInconsistentNaming(result.lines, file.ext);
    if (namingIssue) {
      findings.push(finding({
        analyzer: ANALYZER,
        severity: SEVERITY.LOW,
        title: `Inconsistent naming in ${file.relativePath}`,
        description: namingIssue,
        file: file.relativePath,
        remediation: 'Adopt a consistent naming convention. For JS/TS: camelCase for variables/functions, PascalCase for classes/components.',
      }));
    }

    // Generate content signature for duplicate detection
    const sig = generateSignature(result.lines);
    if (sig) {
      if (!contentSignatures.has(sig)) {
        contentSignatures.set(sig, []);
      }
      contentSignatures.get(sig).push(file.relativePath);
    }
  }

  // Report AI tool fingerprints
  if (stats.aiToolFingerprints.length > 0) {
    const tools = [...new Set(stats.aiToolFingerprints.map(f => f.tool))];
    findings.push(finding({
      analyzer: ANALYZER,
      severity: SEVERITY.INFO,
      title: `AI tool fingerprints detected: ${tools.join(', ')}`,
      description: `Found ${stats.aiToolFingerprints.length} AI tool attribution comments from: ${tools.join(', ')}. AI-generated code isn't inherently bad, but it needs the same review standards as human-written code.`,
      remediation: 'Review AI-generated files for correctness, security, and consistency with the rest of the codebase.',
    }));
  }

  // Report near-duplicate files
  for (const [sig, fileList] of contentSignatures) {
    if (fileList.length > 1) {
      findings.push(finding({
        analyzer: ANALYZER,
        severity: SEVERITY.MEDIUM,
        title: `Near-duplicate files detected (${fileList.length} files)`,
        description: `These files have very similar structure and content: ${fileList.join(', ')}. Duplicated logic is a hallmark of AI-generated code where the tool creates similar solutions for similar prompts.`,
        file: fileList[0],
        remediation: 'Extract shared logic into a reusable module. Apply DRY principle.',
      }));
    }
  }

  // High-level summary findings
  if (stats.silentCatches > 10) {
    findings.push(finding({
      analyzer: ANALYZER,
      severity: SEVERITY.HIGH,
      title: `${stats.silentCatches} silent catch blocks across the codebase`,
      description: `Found ${stats.silentCatches} empty catch blocks total. This level of silent error handling suggests large portions of the codebase were AI-generated without proper review.`,
      remediation: 'Conduct a systematic review of all error handling. Add at minimum error logging to every catch block.',
    }));
  }

  if (stats.todoComments > 20) {
    findings.push(finding({
      analyzer: ANALYZER,
      severity: SEVERITY.MEDIUM,
      title: `${stats.todoComments} unresolved TODO/FIXME comments`,
      description: `Found ${stats.todoComments} TODO/FIXME comments. A high count often indicates AI-generated code with incomplete implementations left as "exercises for the reader."`,
      remediation: 'Triage TODOs: resolve, create tracked issues, or remove if no longer relevant.',
    }));
  }

  return { findings, stats };
}

/**
 * Detect inconsistent naming within a file's function/variable declarations.
 */
function detectInconsistentNaming(lines, ext) {
  if (!['.js', '.mjs', '.cjs', '.jsx', '.ts', '.tsx'].includes(ext)) return null;

  const names = [];
  for (const line of lines) {
    const trimmed = line.trim();

    // Extract function names
    const funcMatch = trimmed.match(/(?:function|const|let|var)\s+([a-zA-Z_$]\w*)/);
    if (funcMatch) names.push(funcMatch[1]);
  }

  if (names.length < 5) return null;

  let camelCount = 0;
  let snakeCount = 0;
  for (const name of names) {
    if (name.includes('_') && name === name.toLowerCase()) snakeCount++;
    else if (/^[a-z]/.test(name) && !name.includes('_')) camelCount++;
  }

  const total = camelCount + snakeCount;
  if (total < 5) return null;

  const ratio = Math.min(camelCount, snakeCount) / total;
  if (ratio > 0.25) {
    return `Mixed naming conventions: ${camelCount} camelCase and ${snakeCount} snake_case declarations. This inconsistency often occurs when code is assembled from multiple AI-generated snippets.`;
  }

  return null;
}

/**
 * Generate a rough content signature for duplicate detection.
 * Strips comments, whitespace, and variable names to find structurally similar files.
 */
function generateSignature(lines) {
  if (lines.length < 15) return null; // Skip small files

  const structural = lines
    .map(l => l.trim())
    .filter(l => l && !l.startsWith('//') && !l.startsWith('#') && !l.startsWith('*') && !l.startsWith('/*'))
    .map(l => {
      // Normalize: replace identifiers and strings with placeholders
      return l
        .replace(/['"][^'"]*['"]/g, 'STR')
        .replace(/\b\d+\b/g, 'NUM')
        .replace(/\b[a-z][a-zA-Z0-9]{0,3}\b/g, 'id');
    })
    .join('|');

  // Simple hash to bucket similar structures
  if (structural.length < 50) return null;

  let hash = 0;
  const sample = structural.slice(0, 500);
  for (let i = 0; i < sample.length; i++) {
    hash = ((hash << 5) - hash + sample.charCodeAt(i)) | 0;
  }
  return String(hash);
}
